(this["webpackJsonpintern-webgl-react-app"]=this["webpackJsonpintern-webgl-react-app"]||[]).push([[0],{27:function(e,n,t){e.exports=t(50)},32:function(e,n,t){},33:function(e,n,t){},48:function(e){e.exports=JSON.parse('{"steps":20,"origin":[{"x":0,"y":0,"z":20},{"x":0,"y":5,"z":15},{"x":0,"y":0,"z":10}],"lookat":[{"x":0,"y":0,"z":0},{"x":0,"y":5,"z":0},{"x":0,"y":10,"z":-10}]}')},49:function(e){e.exports=JSON.parse('{"steps":20,"origin":[{"x":-35,"y":0,"z":0},{"x":0,"y":10,"z":20},{"x":40,"y":0,"z":0}],"lookat":[{"x":-40,"y":10,"z":-40},{"x":0,"y":-10,"z":-40},{"x":40,"y":10,"z":-40}]}')},50:function(e,n,t){"use strict";t.r(n);var a,i=t(13),o=t.n(i),r=t(18),s=t.n(r),l=(t(32),t(1)),u=t(3),c=t(6),d=t(5),f=t(7),h=t(9),m=(t(33),t(4)),p=t.n(m),A=t(8),x=t(2),F=t(12),g=t(10),v=t.n(g),_=t(0),P=t(19),T=2*Math.PI,y=(Math.PI,Math.PI,Math.PI,new _.Pb),b=new _.Pb(1,1,1),S=(new _.Pb(0,1,0),_.S),N=t(35);function L(e){var n=N.parse(window.location.search);return void 0!==n[e]&&n[e]}function w(e,n){var t=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=N.parse(window.location.search),i=Object.assign({},a,Object(x.a)({},e,n)),o=N.stringify(i);if(t)window.location.href="".concat(window.location.pathname,"?").concat(o);else{var r="".concat(window.location.protocol,"//").concat(window.location.host).concat(window.location.pathname,"?").concat(o);window.history.pushState({path:r},"",r)}}var I=["high","normal"],E="normal";function O(){return E}var X=Object(P.getGPUTier)();var U=L("graphics");E=I.includes(U)&&"string"===typeof U?U:function(){switch(X.tier){case"GPU_DESKTOP_TIER_3":case"GPU_DESKTOP_TIER_2":case"GPU_MOBILE_TIER_3":return"high";case"GPU_DESKTOP_TIER_1":default:return"normal"}}();var C=(a={},Object(x.a)(a,"high",{antialias:!1,pixelRatio:S.clamp(window.devicePixelRatio,1,2),maxFrameBufferSize:new _.Ob(1280,720)}),Object(x.a)(a,"normal",{antialias:!1,pixelRatio:1,maxFrameBufferSize:new _.Ob(1280,720)}),a),Q={isDevelopment:!1,baseUrl:"/webgl-react-app"};Q.stats=null===L("stats"),Q.devCamera="true"===L("devCamera"),Q.helpers="true"===L("helpers"),Q.datGui=null===L("gui"),Q.skipTransitions=null===L("skipTransitions"),Q.guiPrecision=.001,Q.viewportPreviewScale=.25,Q.renderBufferFullscreen=!1;var Y=Q,j=C[O()],R=j.maxFrameBufferSize,M=j.pixelRatio,k=Math.sqrt(R.x*R.y),D=k*k,z=new _.Ob;function G(){return{width:z.x*M,height:z.y*M}}function H(e,n,t){var a=function(e,n){var t=e,a=n;if(e*n>D){var i=a/t,o=(t=k)*(a=Math.floor(k*i)),r=Math.sqrt(D/o);t=Math.floor(t*r),a=Math.floor(a*r)}return{width:t,height:a}}(n,t),i=a.width,o=a.height;Y.renderBufferFullscreen&&(i=n,o=t),z.x=i,z.y=o,e.setSize(i,o),e.domElement.style.width="".concat(n,"px"),e.domElement.style.height="".concat(t,"px")}t(11);function B(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1024,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1024,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a={minFilter:_.L,magFilter:_.cb,format:_.sb,type:_.Nb,stencilBuffer:!1};return new _.Tb(e,n,Object.assign({},a,t))}var W=t(15);function V(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:b;e.position.set(t.x*n,t.y*n,t.z*n),e.lookAt(y)}function q(e){return new _.jb(65,e,.1,1e3)}function J(e){return new W.a(e,De.domElement)}var K=t(14),Z=function(){function e(){Object(l.a)(this,e)}return Object(u.a)(e,[{key:"add",value:function(e,n,t){return this}},{key:"listen",value:function(){return this}},{key:"name",value:function(){return this}},{key:"open",value:function(){return this}},{key:"close",value:function(){return this}},{key:"onChange",value:function(e){return this}},{key:"addFolder",value:function(e){return this}},{key:"addColor",value:function(){return this}},{key:"removeFolder",value:function(e){return this}},{key:"remove",value:function(){return this}},{key:"step",value:function(){return this}}]),e}(),$=function(){function e(){Object(l.a)(this,e)}return Object(u.a)(e,[{key:"add",value:function(e,n,t){return this}},{key:"addFolder",value:function(e){return new Z}},{key:"removeFolder",value:function(e){return this}},{key:"addColor",value:function(){return this}},{key:"listen",value:function(){return this}},{key:"name",value:function(){return this}},{key:"close",value:function(){return this}},{key:"step",value:function(){return this}},{key:"onChange",value:function(e){return this}},{key:"setValue",value:function(){return this}},{key:"remove",value:function(){return this}},{key:"open",value:function(){return this}}],[{key:"toggleHide",value:function(){return this}}]),e}(),ee=$;var ne=new ee;function te(e,n){var t=document.createElement("canvas");return t.width=e,t.height=n,{ctx:t.getContext("2d"),canvas:t}}K.a.device.isDesktop||ee.toggleHide();var ae=B(128,128,{depthBuffer:!1,format:_.rb});function ie(e,n){!1===n?(e.wasFrustumCulled=e.frustumCulled,e.wasVisible=e.visible,e.visible=!0,e.frustumCulled=!1):(e.visible=e.wasVisible,e.frustumCulled=e.wasFrustumCulled),e.children.forEach((function(e){return ie(e,n)}))}function oe(e,n){var t=n.aspect;n.aspect=1,n.updateProjectionMatrix(),ie(e,!1),De.setRenderTarget(ae),De.render(e,n),De.setRenderTarget(null),n.aspect=t,n.updateProjectionMatrix(),ie(e,!0)}var re=function e(n){Object(l.a)(this,e),Object.assign(this,n)},se=function(e){function n(){return Object(l.a)(this,n),Object(c.a)(this,Object(d.a)(n).apply(this,arguments))}return Object(f.a)(n,e),n}(v.a);se.json="json",se.image="image",se.threeFBX="fbx",se.threeGLTF="gltf",se.threeTexture="texture";var le=se,ue=function(e){function n(e){var t;return Object(l.a)(this,n),(t=Object(c.a)(this,Object(d.a)(n).call(this))).load=function(){var e=new Image;e.onload=function(){t.asset.data=e,t.emit("loaded",t.asset)},e.onerror=function(){t.emit("error","Failed to load ".concat(t.asset.src))},e.src=t.asset.src},t.asset=e,t}return Object(f.a)(n,e),n}(le),ce=function(e){function n(e){var t;return Object(l.a)(this,n),(t=Object(c.a)(this,Object(d.a)(n).call(this))).load=function(){var e=new XMLHttpRequest;e.onreadystatechange=function(){4===e.readyState&&(4===e.readyState&&200===e.status?(t.asset.data=JSON.parse(e.responseText),t.emit("loaded",t.asset)):t.emit("error","Failed to load ".concat(t.asset.src)))},e.open("GET",t.asset.src,!0),e.send()},t.asset=e,t}return Object(f.a)(n,e),n}(le),de=function(e){function n(e){var t;return Object(l.a)(this,n),(t=Object(c.a)(this,Object(d.a)(n).call(this))).load=function(){(new _.Hb).load(t.asset.src,(function(e){t.asset.data=e,t.emit("loaded",t.asset)}),null,(function(){t.emit("error","Failed to load ".concat(t.asset.src))}))},t.asset=e,t}return Object(f.a)(n,e),n}(le),fe=t(25),he=function(e){function n(e){var t;return Object(l.a)(this,n),(t=Object(c.a)(this,Object(d.a)(n).call(this))).load=function(){(new fe.a).load(t.asset.src,(function(e){t.asset.data=e,t.emit("loaded",t.asset)}),null,(function(){t.emit("error","Failed to load ".concat(t.asset.src))}))},t.asset=e,t}return Object(f.a)(n,e),n}(le),me=t(20),pe=new(t(21).a);pe.setDecoderPath("".concat(Y.baseUrl,"/assets/lib/draco/gltf/")),pe.preload();var Ae,xe=function(e){function n(e){var t;return Object(l.a)(this,n),(t=Object(c.a)(this,Object(d.a)(n).call(this))).load=function(){var e=new me.a;e.setDRACOLoader(pe);e.load(t.asset.src,(function(e){t.asset.data=e,t.emit("loaded",t.asset)}),null,(function(){t.emit("error","Failed to load ".concat(t.asset.src))}))},t.asset=e,t}return Object(f.a)(n,e),n}(le),Fe=(Ae={},Object(x.a)(Ae,le.image,ue),Object(x.a)(Ae,le.json,ce),Object(x.a)(Ae,le.threeTexture,de),Object(x.a)(Ae,le.threeFBX,he),Object(x.a)(Ae,le.threeGLTF,xe),Ae),ge=function(e){function n(){var e,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return Object(l.a)(this,n),(e=Object(c.a)(this,Object(d.a)(n).call(this))).load=function(n){e.loaders=[],n.forEach((function(n){void 0!==Fe[n.type]&&e.loaders.push(new Fe[n.type](n))})),e.loaded=0,e.queue=0,e.currentParallel=0,e.total=e.loaders.length,0===e.total?e.emit("loaded",n):e.loadNextInQueue()},e.loadNextInQueue=function(){if(e.queue<e.total&&e.currentParallel<e.parallelLoads){var n=e.loaders[e.queue];e.queue+=1,e.currentParallel+=1,n.once("loaded",e.onLoaded),n.once("error",e.onError),n.load(),e.loadNextInQueue()}},e.onLoaded=function(){if(e.loaded+=1,e.emit("progress",e.loaded/e.total),e.loaded===e.total){var n=[];e.loaders.forEach((function(e){n.push(e.asset)})),e.emit("loaded",n)}else e.currentParallel-=1,e.loadNextInQueue()},e.onError=function(n){e.emit("error",n)},e.id=t.id||"",e.minParallel=t.minParallel||5,e.maxParallel=t.maxParallel||10,e.parallelLoads=K.a.device.isDesktop?e.maxParallel:e.minParallel,e}return Object(f.a)(n,e),n}(v.a),ve=new(function(e){function n(){var e,t;Object(l.a)(this,n);for(var a=arguments.length,i=new Array(a),o=0;o<a;o++)i[o]=arguments[o];return(t=Object(c.a)(this,(e=Object(d.a)(n)).call.apply(e,[this].concat(i)))).load=function(e,n){var a=new ge({id:e});n.forEach((function(e){void 0===e.args&&(e.args={})})),a.on("progress",(function(e){t.emit("progress",e)})),a.once("loaded",(function(e){t.emit("loaded",e)})),a.once("error",(function(e){t.emit("error",e)})),a.load(n)},t}return Object(f.a)(n,e),n}(v.a)),_e=t(24),Pe=new(function(){function e(){Object(l.a)(this,e),this.assets={}}return Object(u.a)(e,[{key:"add",value:function(e,n){var t;this.assets[e]=this.assets[e]||[],(t=this.assets[e]).push.apply(t,Object(_e.a)(n))}},{key:"get",value:function(e,n){var t=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=this.find(this.assets[e],n);return!!(a&&a instanceof re)&&(t?a:a.data)}},{key:"find",value:function(e,n){return e.find((function(e){return e.id===n}))||!1}}]),e}());var Te=function(e){function n(e){var t;return Object(l.a)(this,n),(t=Object(c.a)(this,Object(d.a)(n).call(this))).preloadGpuCullScene=function(e){},t.toggleHelpers=function(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];t.helpers.visible=e},t.toogleCameras=function(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];t.camera=e?t.cameras.dev:t.cameras.main,t.control=e?t.controls.dev:t.controls.main},t.resize=function(e,n){t.cameras.dev.aspect=e/n,t.cameras.dev.updateProjectionMatrix(),t.cameras.main.aspect=e/n,t.cameras.main.updateProjectionMatrix()},t.update=function(e){},t.dispose=function(){!function e(n,t){if(null!==n&&void 0!==n){if(t&&t.remove(n),n.dispose&&n.dispose(),n.geometry&&n.geometry.dispose(),n.material&&n.material.dispose(),n.children)for(var a=0,i=n.children.length;a<i;)e(n.children[0],n),a++;"Scene"===n.type&&n.dispose(),n=null}}(t.scene,null),t.gui&&ne.removeFolder(t.gui.name)},t.id=e.id||S.generateUUID(),t.clearColor=e.clearColor||0,t.lights=e.lights||[],t.assets=e.assets||[],t.scene=new _.wb,t.cameras={dev:q(z.x/z.y),main:q(z.x/z.y)},t.camera=Y.devCamera?t.cameras.dev:t.cameras.main,V(t.cameras.dev,5),V(t.cameras.main,5),t.controls={},e.controls&&(t.controls.dev=J(t.cameras.dev),t.controls.main=J(t.cameras.main)),t.control=Y.devCamera?t.controls.dev:t.controls.main,e.gui?(t.gui=ne.addFolder("".concat(t.id," scene")),e.guiOpen&&t.gui.open()):t.gui=new $,t.lights.forEach((function(e){t.scene.add(e.light),e.gui(t.gui)})),t}return Object(f.a)(n,e),Object(u.a)(n,[{key:"loadAssets",value:function(){var e=Object(A.a)(p.a.mark((function e(){var n=this;return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,t){try{n.assets.length>0?(ve.once("loaded",(function(t){t.length>0&&Pe.add(n.id,t),e()})),ve.once("error",(function(e){t(e)})),ve.load(n.id,n.assets)):e()}catch(a){t(a)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"createSceneHelpers",value:function(){var e=Object(A.a)(p.a.mark((function e(){var n=this;return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,t){try{n.helpers=new _.B,n.helpers.add(new _.A(10,10),new _.c),n.helpers.visible=Y.helpers,n.scene.add(n.helpers),e()}catch(a){t(a)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"createSceneObjects",value:function(){var e=Object(A.a)(p.a.mark((function e(){return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,n){try{e()}catch(t){n(t)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"setup",value:function(){var e=Object(A.a)(p.a.mark((function e(){return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.loadAssets();case 2:return e.next=4,this.createSceneHelpers();case 4:return e.next=6,this.createSceneObjects();case 6:this.preloadGpuCullScene(!0),oe(this.scene,this.camera),this.preloadGpuCullScene(!1);case 9:case"end":return e.stop()}}),e,this)})));return function(){return e.apply(this,arguments)}}()},{key:"animateIn",value:function(){var e=Object(A.a)(p.a.mark((function e(){return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,n){try{e()}catch(t){n(t)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"animateOut",value:function(){var e=Object(A.a)(p.a.mark((function e(){return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,n){try{e()}catch(t){n(t)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()}]),n}(v.a),ye=t(47)(Promise,h.b),be=function(){function e(n,t,a){var i=this;Object(l.a)(this,e),this.gui=n.addFolder("transition pass"),this.gui.open(),this.scene=new _.wb,this.camera=a,this.active=!1;var o=G(),r=o.width,s=o.height,u=new _.xb({uniforms:{texture0:{value:null},texture1:{value:null},transition:{value:0},resolution:{value:new _.Ob(r,s)}},vertexShader:"\n  void main() {\n    gl_Position = vec4(position, 1.0);\n  }\n",fragmentShader:"\n  uniform sampler2D texture0;\n  uniform sampler2D texture1;\n  uniform float transition;\n  uniform vec2 resolution;\n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec4 texel0 = texture2D(texture0, uv);\n    vec4 texel1 = texture2D(texture1, uv);\n    gl_FragColor = mix(texel0, texel1, transition);\n  }\n"});this.mesh=new _.W(t,u),this.mesh.matrixAutoUpdate=!1,this.mesh.updateMatrix(),this.scene.add(this.mesh),this.gui.add(this.mesh.material.uniforms.transition,"value",0,1).onChange((function(e){i.active=0!==e&&1!==e})).name("transition").listen()}return Object(u.a)(e,[{key:"transition",value:function(){var e=Object(A.a)(p.a.mark((function e(){var n=this;return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(!Y.skipTransitions){e.next=4;break}this.mesh.material.uniforms.transition.value=1,e.next=9;break;case 4:return this.mesh.material.uniforms.transition.value=0,this.active=!0,h.b.killTweensOf(this.mesh.material.uniforms.transition),e.next=9,ye.to(this.mesh.material.uniforms.transition,1,{value:1}).then((function(){n.active=!1}));case 9:case"end":return e.stop()}}),e,this)})));return function(){return e.apply(this,arguments)}}()},{key:"resize",value:function(e,n){this.mesh.material.uniforms.resolution.value.x=e,this.mesh.material.uniforms.resolution.value.y=n}},{key:"render",value:function(e,n,t,a,i){e.update(i),n.update(i),De.setClearColor(e.clearColor),De.setRenderTarget(t),De.render(e.scene,e.camera),De.setClearColor(n.clearColor),De.setRenderTarget(a),De.render(n.scene,n.camera),this.mesh.material.uniforms.texture0.value=t.texture,this.mesh.material.uniforms.texture1.value=a.texture,De.setRenderTarget(null)}}]),e}(),Se={fxaaEnabled:{value:1},fxaaResolution:{value:new _.Ob(1/1024,1/512)}};var Ne={filmEnabled:{value:1},filmNoiseIntensity:{value:.35},filmScanIntensity:{value:.05},filmScanCount:{value:4096},filmGrayscale:{value:0}},Le="\n  ".concat("\n  #define PI 3.14159265359\n","\n  ").concat("\n  highp float rand( const in vec2 uv ) {\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n    return fract(sin(sn) * c);\n  }\n","\n\n  vec3 filmPass(vec3 outgoingColor, vec2 uv) {\n    // Make some noise\n    float dx = rand(uv + time);\n\n    // Add noise\n    vec3 cResult = outgoingColor.rgb + outgoingColor.rgb * clamp(0.1 + dx, 0.0, 1.0);\n\n    // Get us a sine and cosine\n    vec2 sc = vec2(sin(uv.y * filmScanCount), cos(uv.y * filmScanCount));\n\n    // Add scanlines\n    cResult += outgoingColor.rgb * vec3(sc.x, sc.y, sc.x) * filmScanIntensity;\n\n    // Interpolate between source and result by intensity\n    cResult = outgoingColor.rgb + clamp(filmNoiseIntensity, 0.0,1.0) * (cResult - outgoingColor.rgb);\n\n    // Convert to grayscale if desired\n    if (filmGrayscale) {\n      cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\n    }\n\n    return cResult;\n  }\n");var we="\n  uniform vec2 resolution;\n  uniform float time;\n  uniform sampler2D tDiffuse;\n  // FXAA pass\n  ".concat("\n  precision highp float;\n  uniform bool fxaaEnabled;\n  uniform vec2 fxaaResolution;\n  varying vec2 vUv;\n","\n  ").concat("\n  // FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n  //----------------------------------------------------------------------------------\n  // File:        es3-kepler/FXAA/assets/shaders/FXAA_DefaultES.frag\n  // SDK Version: v3.00\n  // Email:       gameworks@nvidia.com\n  // Site:        http://developer.nvidia.com/\n  //\n  // Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n  //\n  // Redistribution and use in source and binary forms, with or without\n  // modification, are permitted provided that the following conditions\n  // are met:\n  //  * Redistributions of source code must retain the above copyright\n  //    notice, this list of conditions and the following disclaimer.\n  //  * Redistributions in binary form must reproduce the above copyright\n  //    notice, this list of conditions and the following disclaimer in the\n  //    documentation and/or other materials provided with the distribution.\n  //  * Neither the name of NVIDIA CORPORATION nor the names of its\n  //    contributors may be used to endorse or promote products derived\n  //    from this software without specific prior written permission.\n  //\n  // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS 'AS IS' AND ANY\n  // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  // PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n  // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n  // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n  // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n  // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n  // OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  //\n  //----------------------------------------------------------------------------------\n\n  #define FXAA_PC 1\n  #define FXAA_GLSL_100 1\n  #define FXAA_QUALITY_PRESET 12\n\n  #define FXAA_GREEN_AS_LUMA 1\n\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_PC_CONSOLE\n      //\n      // The console algorithm for PC is included\n      // for developers targeting really low spec machines.\n      // Likely better to just run FXAA_PC, and use a really low preset.\n      //\n      #define FXAA_PC_CONSOLE 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GLSL_120\n      #define FXAA_GLSL_120 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GLSL_130\n      #define FXAA_GLSL_130 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_3\n      #define FXAA_HLSL_3 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_4\n      #define FXAA_HLSL_4 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_HLSL_5\n      #define FXAA_HLSL_5 0\n  #endif\n  /*==========================================================================*/\n  #ifndef FXAA_GREEN_AS_LUMA\n      //\n      // For those using non-linear color,\n      // and either not able to get luma in alpha, or not wanting to,\n      // this enables FXAA to run using green as a proxy for luma.\n      // So with this enabled, no need to pack luma in alpha.\n      //\n      // This will turn off AA on anything which lacks some amount of green.\n      // Pure red and blue or combination of only R and B, will get no AA.\n      //\n      // Might want to lower the settings for both,\n      //    fxaaConsoleEdgeThresholdMin\n      //    fxaaQualityEdgeThresholdMin\n      // In order to insure AA does not get turned off on colors\n      // which contain a minor amount of green.\n      //\n      // 1 = On.\n      // 0 = Off.\n      //\n      #define FXAA_GREEN_AS_LUMA 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_EARLY_EXIT\n      //\n      // Controls algorithm's early exit path.\n      // On PS3 turning this ON adds 2 cycles to the shader.\n      // On 360 turning this OFF adds 10ths of a millisecond to the shader.\n      // Turning this off on console will result in a more blurry image.\n      // So this defaults to on.\n      //\n      // 1 = On.\n      // 0 = Off.\n      //\n      #define FXAA_EARLY_EXIT 1\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_DISCARD\n      //\n      // Only valid for PC OpenGL currently.\n      // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n      //\n      // 1 = Use discard on pixels which don't need AA.\n      //     For APIs which enable concurrent TEX+ROP from same surface.\n      // 0 = Return unchanged color on pixels which don't need AA.\n      //\n      #define FXAA_DISCARD 0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_FAST_PIXEL_OFFSET\n      //\n      // Used for GLSL 120 only.\n      //\n      // 1 = GL API supports fast pixel offsets\n      // 0 = do not use fast pixel offsets\n      //\n      #ifdef GL_EXT_gpu_shader4\n          #define FXAA_FAST_PIXEL_OFFSET 1\n      #endif\n      #ifdef GL_NV_gpu_shader5\n          #define FXAA_FAST_PIXEL_OFFSET 1\n      #endif\n      #ifdef GL_ARB_gpu_shader5\n          #define FXAA_FAST_PIXEL_OFFSET 1\n      #endif\n      #ifndef FXAA_FAST_PIXEL_OFFSET\n          #define FXAA_FAST_PIXEL_OFFSET 0\n      #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #ifndef FXAA_GATHER4_ALPHA\n      //\n      // 1 = API supports gather4 on alpha channel.\n      // 0 = API does not support gather4 on alpha channel.\n      //\n      #if (FXAA_HLSL_5 == 1)\n          #define FXAA_GATHER4_ALPHA 1\n      #endif\n      #ifdef GL_ARB_gpu_shader5\n          #define FXAA_GATHER4_ALPHA 1\n      #endif\n      #ifdef GL_NV_gpu_shader5\n          #define FXAA_GATHER4_ALPHA 1\n      #endif\n      #ifndef FXAA_GATHER4_ALPHA\n          #define FXAA_GATHER4_ALPHA 0\n      #endif\n  #endif\n\n\n  /*============================================================================\n                          FXAA QUALITY - TUNING KNOBS\n  ------------------------------------------------------------------------------\n  NOTE the other tuning knobs are now in the shader function inputs!\n  ============================================================================*/\n  #ifndef FXAA_QUALITY_PRESET\n      //\n      // Choose the quality preset.\n      // This needs to be compiled into the shader as it effects code.\n      // Best option to include multiple presets is to\n      // in each shader define the preset, then include this file.\n      //\n      // OPTIONS\n      // -----------------------------------------------------------------------\n      // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n      // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n      // 39       - no dither, very expensive\n      //\n      // NOTES\n      // -----------------------------------------------------------------------\n      // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n      // 13 = about same speed as FXAA 3.9 and better than 12\n      // 23 = closest to FXAA 3.9 visually and performance wise\n      //  _ = the lowest digit is directly related to performance\n      // _  = the highest digit is directly related to style\n      //\n      #define FXAA_QUALITY_PRESET 12\n  #endif\n\n\n  /*============================================================================\n\n                              FXAA QUALITY - PRESETS\n\n  ============================================================================*/\n\n  /*============================================================================\n                        FXAA QUALITY - MEDIUM DITHER PRESETS\n  ============================================================================*/\n  #if (FXAA_QUALITY_PRESET == 10)\n      #define FXAA_QUALITY_PS 3\n      #define FXAA_QUALITY_P0 1.5\n      #define FXAA_QUALITY_P1 3.0\n      #define FXAA_QUALITY_P2 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 11)\n      #define FXAA_QUALITY_PS 4\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 3.0\n      #define FXAA_QUALITY_P3 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 12)\n      #define FXAA_QUALITY_PS 5\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 4.0\n      #define FXAA_QUALITY_P4 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 13)\n      #define FXAA_QUALITY_PS 6\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 4.0\n      #define FXAA_QUALITY_P5 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 14)\n      #define FXAA_QUALITY_PS 7\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 4.0\n      #define FXAA_QUALITY_P6 12.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 15)\n      #define FXAA_QUALITY_PS 8\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 4.0\n      #define FXAA_QUALITY_P7 12.0\n  #endif\n\n  /*============================================================================\n                        FXAA QUALITY - LOW DITHER PRESETS\n  ============================================================================*/\n  #if (FXAA_QUALITY_PRESET == 20)\n      #define FXAA_QUALITY_PS 3\n      #define FXAA_QUALITY_P0 1.5\n      #define FXAA_QUALITY_P1 2.0\n      #define FXAA_QUALITY_P2 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 21)\n      #define FXAA_QUALITY_PS 4\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 22)\n      #define FXAA_QUALITY_PS 5\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 23)\n      #define FXAA_QUALITY_PS 6\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 24)\n      #define FXAA_QUALITY_PS 7\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 3.0\n      #define FXAA_QUALITY_P6 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 25)\n      #define FXAA_QUALITY_PS 8\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 4.0\n      #define FXAA_QUALITY_P7 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 26)\n      #define FXAA_QUALITY_PS 9\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 4.0\n      #define FXAA_QUALITY_P8 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 27)\n      #define FXAA_QUALITY_PS 10\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 4.0\n      #define FXAA_QUALITY_P9 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 28)\n      #define FXAA_QUALITY_PS 11\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 2.0\n      #define FXAA_QUALITY_P9 4.0\n      #define FXAA_QUALITY_P10 8.0\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_QUALITY_PRESET == 29)\n      #define FXAA_QUALITY_PS 12\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.5\n      #define FXAA_QUALITY_P2 2.0\n      #define FXAA_QUALITY_P3 2.0\n      #define FXAA_QUALITY_P4 2.0\n      #define FXAA_QUALITY_P5 2.0\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 2.0\n      #define FXAA_QUALITY_P9 2.0\n      #define FXAA_QUALITY_P10 4.0\n      #define FXAA_QUALITY_P11 8.0\n  #endif\n\n  /*============================================================================\n                        FXAA QUALITY - EXTREME QUALITY\n  ============================================================================*/\n  #if (FXAA_QUALITY_PRESET == 39)\n      #define FXAA_QUALITY_PS 12\n      #define FXAA_QUALITY_P0 1.0\n      #define FXAA_QUALITY_P1 1.0\n      #define FXAA_QUALITY_P2 1.0\n      #define FXAA_QUALITY_P3 1.0\n      #define FXAA_QUALITY_P4 1.0\n      #define FXAA_QUALITY_P5 1.5\n      #define FXAA_QUALITY_P6 2.0\n      #define FXAA_QUALITY_P7 2.0\n      #define FXAA_QUALITY_P8 2.0\n      #define FXAA_QUALITY_P9 2.0\n      #define FXAA_QUALITY_P10 4.0\n      #define FXAA_QUALITY_P11 8.0\n  #endif\n\n\n\n  /*============================================================================\n\n                                  API PORTING\n\n  ============================================================================*/\n  #if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n      #define FxaaBool bool\n      #define FxaaDiscard discard\n      #define FxaaFloat float\n      #define FxaaFloat2 vec2\n      #define FxaaFloat3 vec3\n      #define FxaaFloat4 vec4\n      #define FxaaHalf float\n      #define FxaaHalf2 vec2\n      #define FxaaHalf3 vec3\n      #define FxaaHalf4 vec4\n      #define FxaaInt2 ivec2\n      #define FxaaSat(x) clamp(x, 0.0, 1.0)\n      #define FxaaTex sampler2D\n  #else\n      #define FxaaBool bool\n      #define FxaaDiscard clip(-1)\n      #define FxaaFloat float\n      #define FxaaFloat2 float2\n      #define FxaaFloat3 float3\n      #define FxaaFloat4 float4\n      #define FxaaHalf half\n      #define FxaaHalf2 half2\n      #define FxaaHalf3 half3\n      #define FxaaHalf4 half4\n      #define FxaaSat(x) saturate(x)\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GLSL_100 == 1)\n    #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n    #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GLSL_120 == 1)\n      // Requires,\n      //  #version 120\n      // And at least,\n      //  #extension GL_EXT_gpu_shader4 : enable\n      //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n      #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n      #if (FXAA_FAST_PIXEL_OFFSET == 1)\n          #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n      #else\n          #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n      #endif\n      #if (FXAA_GATHER4_ALPHA == 1)\n          // use #extension GL_ARB_gpu_shader5 : enable\n          #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n          #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n          #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n          #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n      #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_GLSL_130 == 1)\n      // Requires #version 130 or better\n      #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n      #if (FXAA_GATHER4_ALPHA == 1)\n          // use #extension GL_ARB_gpu_shader5 : enable\n          #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n          #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n          #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n          #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n      #endif\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_HLSL_3 == 1)\n      #define FxaaInt2 float2\n      #define FxaaTex sampler2D\n      #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n      #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_HLSL_4 == 1)\n      #define FxaaInt2 int2\n      struct FxaaTex { SamplerState smpl; Texture2D tex; };\n      #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n  #endif\n  /*--------------------------------------------------------------------------*/\n  #if (FXAA_HLSL_5 == 1)\n      #define FxaaInt2 int2\n      struct FxaaTex { SamplerState smpl; Texture2D tex; };\n      #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n      #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n      #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n      #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n      #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n      #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n  #endif\n\n\n  /*============================================================================\n                      GREEN AS LUMA OPTION SUPPORT FUNCTION\n  ============================================================================*/\n  #if (FXAA_GREEN_AS_LUMA == 0)\n      FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n  #else\n      FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n  #endif\n\n\n\n\n  /*============================================================================\n\n                                FXAA3 QUALITY - PC\n\n  ============================================================================*/\n  #if (FXAA_PC == 1)\n  /*--------------------------------------------------------------------------*/\n  FxaaFloat4 FxaaPixelShader(\n      //\n      // Use noperspective interpolation here (turn off perspective interpolation).\n      // {xy} = center of pixel\n      FxaaFloat2 pos,\n      //\n      // Used only for FXAA Console, and not used on the 360 version.\n      // Use noperspective interpolation here (turn off perspective interpolation).\n      // {xy_} = upper left of pixel\n      // {_zw} = lower right of pixel\n      FxaaFloat4 fxaaConsolePosPos,\n      //\n      // Input color texture.\n      // {rgb_} = color in linear or perceptual color space\n      // if (FXAA_GREEN_AS_LUMA == 0)\n      //     {__a} = luma in perceptual color space (not linear)\n      FxaaTex tex,\n      //\n      // Only used on the optimized 360 version of FXAA Console.\n      // For everything but 360, just use the same input here as for tex.\n      // For 360, same texture, just alias with a 2nd sampler.\n      // This sampler needs to have an exponent bias of -1.\n      FxaaTex fxaaConsole360TexExpBiasNegOne,\n      //\n      // Only used on the optimized 360 version of FXAA Console.\n      // For everything but 360, just use the same input here as for tex.\n      // For 360, same texture, just alias with a 3nd sampler.\n      // This sampler needs to have an exponent bias of -2.\n      FxaaTex fxaaConsole360TexExpBiasNegTwo,\n      //\n      // Only used on FXAA Quality.\n      // This must be from a constant/uniform.\n      // {x_} = 1.0/screenWidthInPixels\n      // {_y} = 1.0/screenHeightInPixels\n      FxaaFloat2 fxaaQualityRcpFrame,\n      //\n      // Only used on FXAA Console.\n      // This must be from a constant/uniform.\n      // This effects sub-pixel AA quality and inversely sharpness.\n      //   Where N ranges between,\n      //     N = 0.50 (default)\n      //     N = 0.33 (sharper)\n      // {x__} = -N/screenWidthInPixels\n      // {_y_} = -N/screenHeightInPixels\n      // {_z_} =  N/screenWidthInPixels\n      // {__w} =  N/screenHeightInPixels\n      FxaaFloat4 fxaaConsoleRcpFrameOpt,\n      //\n      // Only used on FXAA Console.\n      // Not used on 360, but used on PS3 and PC.\n      // This must be from a constant/uniform.\n      // {x__} = -2.0/screenWidthInPixels\n      // {_y_} = -2.0/screenHeightInPixels\n      // {_z_} =  2.0/screenWidthInPixels\n      // {__w} =  2.0/screenHeightInPixels\n      FxaaFloat4 fxaaConsoleRcpFrameOpt2,\n      //\n      // Only used on FXAA Console.\n      // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n      // This must be from a constant/uniform.\n      // {x__} =  8.0/screenWidthInPixels\n      // {_y_} =  8.0/screenHeightInPixels\n      // {_z_} = -4.0/screenWidthInPixels\n      // {__w} = -4.0/screenHeightInPixels\n      FxaaFloat4 fxaaConsole360RcpFrameOpt2,\n      //\n      // Only used on FXAA Quality.\n      // This used to be the FXAA_QUALITY_SUBPIX define.\n      // It is here now to allow easier tuning.\n      // Choose the amount of sub-pixel aliasing removal.\n      // This can effect sharpness.\n      //   1.00 - upper limit (softer)\n      //   0.75 - default amount of filtering\n      //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n      //   0.25 - almost off\n      //   0.00 - completely off\n      FxaaFloat fxaaQualitySubpix,\n      //\n      // Only used on FXAA Quality.\n      // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n      // It is here now to allow easier tuning.\n      // The minimum amount of local contrast required to apply algorithm.\n      //   0.333 - too little (faster)\n      //   0.250 - low quality\n      //   0.166 - default\n      //   0.125 - high quality\n      //   0.063 - overkill (slower)\n      FxaaFloat fxaaQualityEdgeThreshold,\n      //\n      // Only used on FXAA Quality.\n      // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n      // It is here now to allow easier tuning.\n      // Trims the algorithm from processing darks.\n      //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n      //   0.0625 - high quality (faster)\n      //   0.0312 - visible limit (slower)\n      // Special notes when using FXAA_GREEN_AS_LUMA,\n      //   Likely want to set this to zero.\n      //   As colors that are mostly not-green\n      //   will appear very dark in the green channel!\n      //   Tune by looking at mostly non-green content,\n      //   then start at zero and increase until aliasing is a problem.\n      FxaaFloat fxaaQualityEdgeThresholdMin,\n      //\n      // Only used on FXAA Console.\n      // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n      // It is here now to allow easier tuning.\n      // This does not effect PS3, as this needs to be compiled in.\n      //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n      //   Due to the PS3 being ALU bound,\n      //   there are only three safe values here: 2 and 4 and 8.\n      //   These options use the shaders ability to a free *|/ by 2|4|8.\n      // For all other platforms can be a non-power of two.\n      //   8.0 is sharper (default!!!)\n      //   4.0 is softer\n      //   2.0 is really soft (good only for vector graphics inputs)\n      FxaaFloat fxaaConsoleEdgeSharpness,\n      //\n      // Only used on FXAA Console.\n      // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n      // It is here now to allow easier tuning.\n      // This does not effect PS3, as this needs to be compiled in.\n      //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n      //   Due to the PS3 being ALU bound,\n      //   there are only two safe values here: 1/4 and 1/8.\n      //   These options use the shaders ability to a free *|/ by 2|4|8.\n      // The console setting has a different mapping than the quality setting.\n      // Other platforms can use other values.\n      //   0.125 leaves less aliasing, but is softer (default!!!)\n      //   0.25 leaves more aliasing, and is sharper\n      FxaaFloat fxaaConsoleEdgeThreshold,\n      //\n      // Only used on FXAA Console.\n      // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n      // It is here now to allow easier tuning.\n      // Trims the algorithm from processing darks.\n      // The console setting has a different mapping than the quality setting.\n      // This only applies when FXAA_EARLY_EXIT is 1.\n      // This does not apply to PS3,\n      // PS3 was simplified to avoid more shader instructions.\n      //   0.06 - faster but more aliasing in darks\n      //   0.05 - default\n      //   0.04 - slower and less aliasing in darks\n      // Special notes when using FXAA_GREEN_AS_LUMA,\n      //   Likely want to set this to zero.\n      //   As colors that are mostly not-green\n      //   will appear very dark in the green channel!\n      //   Tune by looking at mostly non-green content,\n      //   then start at zero and increase until aliasing is a problem.\n      FxaaFloat fxaaConsoleEdgeThresholdMin,\n      //\n      // Extra constants for 360 FXAA Console only.\n      // Use zeros or anything else for other platforms.\n      // These must be in physical constant registers and NOT immediates.\n      // Immediates will result in compiler un-optimizing.\n      // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n      FxaaFloat4 fxaaConsole360ConstDir\n  ) {\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat2 posM;\n      posM.x = pos.x;\n      posM.y = pos.y;\n      #if (FXAA_GATHER4_ALPHA == 1)\n          #if (FXAA_DISCARD == 0)\n              FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n              #if (FXAA_GREEN_AS_LUMA == 0)\n                  #define lumaM rgbyM.w\n              #else\n                  #define lumaM rgbyM.y\n              #endif\n          #endif\n          #if (FXAA_GREEN_AS_LUMA == 0)\n              FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n              FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n          #else\n              FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n              FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n          #endif\n          #if (FXAA_DISCARD == 1)\n              #define lumaM luma4A.w\n          #endif\n          #define lumaE luma4A.z\n          #define lumaS luma4A.x\n          #define lumaSE luma4A.y\n          #define lumaNW luma4B.w\n          #define lumaN luma4B.z\n          #define lumaW luma4B.x\n      #else\n          FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n          #if (FXAA_GREEN_AS_LUMA == 0)\n              #define lumaM rgbyM.w\n          #else\n              #define lumaM rgbyM.y\n          #endif\n          #if (FXAA_GLSL_100 == 1)\n            FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n          #else\n            FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n          #endif\n      #endif\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat maxSM = max(lumaS, lumaM);\n      FxaaFloat minSM = min(lumaS, lumaM);\n      FxaaFloat maxESM = max(lumaE, maxSM);\n      FxaaFloat minESM = min(lumaE, minSM);\n      FxaaFloat maxWN = max(lumaN, lumaW);\n      FxaaFloat minWN = min(lumaN, lumaW);\n      FxaaFloat rangeMax = max(maxWN, maxESM);\n      FxaaFloat rangeMin = min(minWN, minESM);\n      FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n      FxaaFloat range = rangeMax - rangeMin;\n      FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n      FxaaBool earlyExit = range < rangeMaxClamped;\n  /*--------------------------------------------------------------------------*/\n      if(earlyExit)\n          #if (FXAA_DISCARD == 1)\n              FxaaDiscard;\n          #else\n              return rgbyM;\n          #endif\n  /*--------------------------------------------------------------------------*/\n      #if (FXAA_GATHER4_ALPHA == 0)\n          #if (FXAA_GLSL_100 == 1)\n            FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n          #else\n            FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n            FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n          #endif\n      #else\n          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n      #endif\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat lumaNS = lumaN + lumaS;\n      FxaaFloat lumaWE = lumaW + lumaE;\n      FxaaFloat subpixRcpRange = 1.0/range;\n      FxaaFloat subpixNSWE = lumaNS + lumaWE;\n      FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n      FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat lumaNESE = lumaNE + lumaSE;\n      FxaaFloat lumaNWNE = lumaNW + lumaNE;\n      FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n      FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat lumaNWSW = lumaNW + lumaSW;\n      FxaaFloat lumaSWSE = lumaSW + lumaSE;\n      FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n      FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n      FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n      FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n      FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n      FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n      FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n      FxaaBool horzSpan = edgeHorz >= edgeVert;\n      FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n  /*--------------------------------------------------------------------------*/\n      if(!horzSpan) lumaN = lumaW;\n      if(!horzSpan) lumaS = lumaE;\n      if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n      FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat gradientN = lumaN - lumaM;\n      FxaaFloat gradientS = lumaS - lumaM;\n      FxaaFloat lumaNN = lumaN + lumaM;\n      FxaaFloat lumaSS = lumaS + lumaM;\n      FxaaBool pairN = abs(gradientN) >= abs(gradientS);\n      FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n      if(pairN) lengthSign = -lengthSign;\n      FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat2 posB;\n      posB.x = posM.x;\n      posB.y = posM.y;\n      FxaaFloat2 offNP;\n      offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n      offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n      if(!horzSpan) posB.x += lengthSign * 0.5;\n      if( horzSpan) posB.y += lengthSign * 0.5;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat2 posN;\n      posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n      posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n      FxaaFloat2 posP;\n      posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n      posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n      FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n      FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n      FxaaFloat subpixE = subpixC * subpixC;\n      FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n  /*--------------------------------------------------------------------------*/\n      if(!pairN) lumaNN = lumaSS;\n      FxaaFloat gradientScaled = gradient * 1.0/4.0;\n      FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n      FxaaFloat subpixF = subpixD * subpixE;\n      FxaaBool lumaMLTZero = lumaMM < 0.0;\n  /*--------------------------------------------------------------------------*/\n      lumaEndN -= lumaNN * 0.5;\n      lumaEndP -= lumaNN * 0.5;\n      FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n      FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n      if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n      if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n      FxaaBool doneNP = (!doneN) || (!doneP);\n      if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n      if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n  /*--------------------------------------------------------------------------*/\n      if(doneNP) {\n          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n          doneN = abs(lumaEndN) >= gradientScaled;\n          doneP = abs(lumaEndP) >= gradientScaled;\n          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n          doneNP = (!doneN) || (!doneP);\n          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n  /*--------------------------------------------------------------------------*/\n          #if (FXAA_QUALITY_PS > 3)\n          if(doneNP) {\n              if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n              if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n              if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n              if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n              doneN = abs(lumaEndN) >= gradientScaled;\n              doneP = abs(lumaEndP) >= gradientScaled;\n              if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n              if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n              doneNP = (!doneN) || (!doneP);\n              if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n              if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n  /*--------------------------------------------------------------------------*/\n              #if (FXAA_QUALITY_PS > 4)\n              if(doneNP) {\n                  if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                  if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                  if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                  if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                  doneN = abs(lumaEndN) >= gradientScaled;\n                  doneP = abs(lumaEndP) >= gradientScaled;\n                  if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n                  if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n                  doneNP = (!doneN) || (!doneP);\n                  if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n                  if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n  /*--------------------------------------------------------------------------*/\n                  #if (FXAA_QUALITY_PS > 5)\n                  if(doneNP) {\n                      if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                      if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                      if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                      if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                      doneN = abs(lumaEndN) >= gradientScaled;\n                      doneP = abs(lumaEndP) >= gradientScaled;\n                      if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n                      if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n                      doneNP = (!doneN) || (!doneP);\n                      if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n                      if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n  /*--------------------------------------------------------------------------*/\n                      #if (FXAA_QUALITY_PS > 6)\n                      if(doneNP) {\n                          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                          doneN = abs(lumaEndN) >= gradientScaled;\n                          doneP = abs(lumaEndP) >= gradientScaled;\n                          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n                          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n                          doneNP = (!doneN) || (!doneP);\n                          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n                          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n  /*--------------------------------------------------------------------------*/\n                          #if (FXAA_QUALITY_PS > 7)\n                          if(doneNP) {\n                              if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                              if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                              if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                              if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                              doneN = abs(lumaEndN) >= gradientScaled;\n                              doneP = abs(lumaEndP) >= gradientScaled;\n                              if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n                              if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n                              doneNP = (!doneN) || (!doneP);\n                              if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n                              if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n  /*--------------------------------------------------------------------------*/\n      #if (FXAA_QUALITY_PS > 8)\n      if(doneNP) {\n          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n          doneN = abs(lumaEndN) >= gradientScaled;\n          doneP = abs(lumaEndP) >= gradientScaled;\n          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n          doneNP = (!doneN) || (!doneP);\n          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n  /*--------------------------------------------------------------------------*/\n          #if (FXAA_QUALITY_PS > 9)\n          if(doneNP) {\n              if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n              if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n              if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n              if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n              doneN = abs(lumaEndN) >= gradientScaled;\n              doneP = abs(lumaEndP) >= gradientScaled;\n              if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n              if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n              doneNP = (!doneN) || (!doneP);\n              if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n              if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n  /*--------------------------------------------------------------------------*/\n              #if (FXAA_QUALITY_PS > 10)\n              if(doneNP) {\n                  if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                  if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                  if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                  if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                  doneN = abs(lumaEndN) >= gradientScaled;\n                  doneP = abs(lumaEndP) >= gradientScaled;\n                  if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n                  if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n                  doneNP = (!doneN) || (!doneP);\n                  if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n                  if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n  /*--------------------------------------------------------------------------*/\n                  #if (FXAA_QUALITY_PS > 11)\n                  if(doneNP) {\n                      if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                      if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                      if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                      if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                      doneN = abs(lumaEndN) >= gradientScaled;\n                      doneP = abs(lumaEndP) >= gradientScaled;\n                      if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n                      if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n                      doneNP = (!doneN) || (!doneP);\n                      if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n                      if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n  /*--------------------------------------------------------------------------*/\n                      #if (FXAA_QUALITY_PS > 12)\n                      if(doneNP) {\n                          if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n                          if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n                          if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n                          if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n                          doneN = abs(lumaEndN) >= gradientScaled;\n                          doneP = abs(lumaEndP) >= gradientScaled;\n                          if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n                          if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n                          doneNP = (!doneN) || (!doneP);\n                          if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n                          if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n  /*--------------------------------------------------------------------------*/\n                      }\n                      #endif\n  /*--------------------------------------------------------------------------*/\n                  }\n                  #endif\n  /*--------------------------------------------------------------------------*/\n              }\n              #endif\n  /*--------------------------------------------------------------------------*/\n          }\n          #endif\n  /*--------------------------------------------------------------------------*/\n      }\n      #endif\n  /*--------------------------------------------------------------------------*/\n                          }\n                          #endif\n  /*--------------------------------------------------------------------------*/\n                      }\n                      #endif\n  /*--------------------------------------------------------------------------*/\n                  }\n                  #endif\n  /*--------------------------------------------------------------------------*/\n              }\n              #endif\n  /*--------------------------------------------------------------------------*/\n          }\n          #endif\n  /*--------------------------------------------------------------------------*/\n      }\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat dstN = posM.x - posN.x;\n      FxaaFloat dstP = posP.x - posM.x;\n      if(!horzSpan) dstN = posM.y - posN.y;\n      if(!horzSpan) dstP = posP.y - posM.y;\n  /*--------------------------------------------------------------------------*/\n      FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n      FxaaFloat spanLength = (dstP + dstN);\n      FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n      FxaaFloat spanLengthRcp = 1.0/spanLength;\n  /*--------------------------------------------------------------------------*/\n      FxaaBool directionN = dstN < dstP;\n      FxaaFloat dst = min(dstN, dstP);\n      FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n      FxaaFloat subpixG = subpixF * subpixF;\n      FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n      FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n  /*--------------------------------------------------------------------------*/\n      FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n      FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n      if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n      if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n      #if (FXAA_DISCARD == 1)\n          return FxaaTexTop(tex, posM);\n      #else\n          return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n      #endif\n  }\n  /*==========================================================================*/\n  #endif\n","\n  // Film pass\n  ").concat("\n  uniform bool filmEnabled;\n  uniform bool filmGrayscale;\n  uniform float filmNoiseIntensity;\n  uniform float filmScanIntensity;\n  uniform float filmScanCount;\n","\n  ").concat(Le,"\n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec4 outgoingColor = texture2D(tDiffuse, uv);\n    // FXAA pass\n    ").concat("\n  // FXAA pass start\n  if (fxaaEnabled) {\n    outgoingColor = FxaaPixelShader(\n      uv,\n      vec4(0.0),\n      tDiffuse,\n      tDiffuse,\n      tDiffuse,\n      fxaaResolution,\n      vec4(0.0),\n      vec4(0.0),\n      vec4(0.0),\n      0.75,\n      0.166,\n      0.0833,\n      0.0,\n      0.0,\n      0.0,\n      vec4(0.0)\n    );\n    // TODO avoid querying texture twice for same texel\n    outgoingColor.a = texture2D(tDiffuse, uv).a;\n  }\n  // FXAA pass end\n","\n    // Film pass\n    ").concat("\n  // Film pass start\n  if (filmEnabled) {\n    outgoingColor.rgb = filmPass(outgoingColor.rgb, uv);\n  }\n  // Film pass end\n","\n    gl_FragColor.rgb = outgoingColor.rgb;\n    gl_FragColor.a = outgoingColor.a;\n  }\n"),Ie=function(){function e(n,t,a){Object(l.a)(this,e),this.gui=n.addFolder("final pass"),this.gui.open(),this.scene=new _.wb,this.camera=a;var i=G(),o=i.width,r=i.height,s=new _.xb({uniforms:_.Mb.merge([{time:{value:0},tDiffuse:{value:null},resolution:{value:new _.Ob(o,r)}},Se,Ne]),vertexShader:"\n  void main() {\n    gl_Position = vec4(position, 1.0);\n  }\n",fragmentShader:we});!function(e,n){var t=e.addFolder("fxaa pass");t.open(),t.add(n.uniforms.fxaaEnabled,"value",0,1,1).name("enabled")}(this.gui,s),function(e,n){var t=e.addFolder("film pass");t.open(),t.add(n.uniforms.filmEnabled,"value",0,1,1).name("enabled"),t.add(n.uniforms.filmNoiseIntensity,"value",0,1).name("noise intensity"),t.add(n.uniforms.filmScanIntensity,"value",0,1).name("scan intensity"),t.add(n.uniforms.filmScanCount,"value",0,4096).name("scan count"),t.add(n.uniforms.filmGrayscale,"value",0,1,1).name("gayscale")}(this.gui,s),this.mesh=new _.W(t,s),this.mesh.matrixAutoUpdate=!1,this.mesh.updateMatrix(),this.scene.add(this.mesh)}return Object(u.a)(e,[{key:"resize",value:function(e,n){this.mesh.material.uniforms.resolution.value.x=e,this.mesh.material.uniforms.resolution.value.y=n,this.mesh.material.uniforms.fxaaResolution.value.x=1/e,this.mesh.material.uniforms.fxaaResolution.value.y=1/n}},{key:"render",value:function(e,n,t){De.setRenderTarget(n),De.render(e.scene,e.camera),De.setRenderTarget(null),this.mesh.material.uniforms.tDiffuse.value=n.texture,this.mesh.material.uniforms.time.value+=t,De.render(this.scene,this.camera)}},{key:"screenshotRender",value:function(e,n,t,a,i){this.mesh.material.uniforms.tDiffuse.value=t.texture,this.mesh.material.uniforms.time.value+=i,De.setRenderTarget(a),De.render(this.scene,this.camera)}}]),e}(),Ee=function(e){function n(e,t){var a;return Object(l.a)(this,n),(a=Object(c.a)(this,Object(d.a)(n).call(this,{id:e,clearColor:t}))).camera.position.set(0,0,10),a.camera.lookAt(y),a}return Object(f.a)(n,e),n}(Te),Oe=function(){function e(n){Object(l.a)(this,e),this.gui=n.addFolder("post processing"),this.gui.open();var t=function(){var e=new _.i,n=new _.h(new Float32Array([-1,-1,0,-1,4,0,4,-1,0]),3);return e.setAttribute("position",n),e.setIndex([0,2,1]),e}();this.camera=new _.ib(-1,1,1,-1,0,1);var a=G(),i=a.width,o=a.height,r={stencilBuffer:!1};this.renderTargetA=B(i,o,r),this.renderTargetB=B(i,o,r),this.renderTargetC=B(i,o,r),this.transitionPass=new be(this.gui,t,this.camera),this.finalPass=new Ie(this.gui,t,this.camera);var s=new Ee("post scene a",0),u=new Ee("post scene b",0);s.setup(),u.setup(),this.setScenes(s,u),this.resize()}return Object(u.a)(e,[{key:"setScenes",value:function(e,n){this.sceneA=e,this.sceneB=n}},{key:"resize",value:function(){var e=Y.devCamera?Y.viewportPreviewScale:1,n=G(),t=n.width,a=n.height;t*=e,a*=e,this.renderTargetA.setSize(t,a),this.renderTargetB.setSize(t,a),this.renderTargetC.setSize(t,a),this.transitionPass.resize(t,a),this.finalPass.resize(t,a)}},{key:"render",value:function(e){this.currentScene=0===this.transitionPass.mesh.material.uniforms.transition.value?this.sceneA:this.sceneB,this.lastPass=this.currentScene,this.transitionPass.active?(this.transitionPass.render(this.sceneA,this.sceneB,this.renderTargetA,this.renderTargetB,e),this.lastPass=this.transitionPass):(De.setClearColor(this.currentScene.clearColor),this.currentScene.update(e)),this.finalPass.render(this.lastPass,this.renderTargetC,e)}}]),e}(),Xe=C[O()],Ue=Xe.pixelRatio,Ce=Xe.antialias,Qe=new _.Ub({antialias:Ce,powerPreference:"high-performance",stencil:!1});Qe.setClearColor(0),Qe.debug.checkShaderErrors=Y.isDevelopment;var Ye=ne.addFolder("rendering");Ye.open(),Qe.setPixelRatio(Ue),Qe.setScissorTest(!0),H(Qe,window.innerWidth,window.innerHeight);var je=new Oe(Ye),Re=Qe.getContext(),Me=Re.getExtension("WEBGL_debug_renderer_info"),ke=Re.getParameter(Me.UNMASKED_RENDERER_WEBGL);Y.isDevelopment&&console.log("Graphics: ".concat(O(),"\nGPU: ").concat(ke,"\nTier: ").concat(X.tier));var De=Qe;var ze=new(Y.isDevelopment?function(){var e=document.createElement("div");e.style.cssText="width:80px;opacity:0.9;cursor:pointer;z-index:100000;top:48px;position:absolute;";var n=document.createElement("div");n.style.cssText="padding:0 0 3px 3px;text-align:left;background-color:rgb(0, 0, 0);",e.appendChild(n);var t=document.createElement("div");t.style.cssText="color:rgb(255, 255, 255);font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px",t.innerHTML="WebGLRenderer",n.appendChild(t);for(var a=[],i=0;i<9;i++)a[i]=document.createElement("div"),a[i].style.cssText="color:rgb(255, 255, 255);background-color:rgb(0, 0, 0);font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px",n.appendChild(a[i]),a[i].innerHTML="-";var o=Date.now();return{domElement:e,update:function(e){console.assert(e instanceof _.Ub),Date.now()-o<1e3/30||(o=Date.now(),a[0].textContent="=== Memory ===",a[1].textContent="Programs: "+e.info.programs.length,a[2].textContent="Geometries: "+e.info.memory.geometries,a[3].textContent="Textures: "+e.info.memory.textures,a[4].textContent="=== Render ===",a[5].textContent="Calls: "+e.info.render.calls,a[6].textContent="Triangles: "+e.info.render.triangles,a[7].textContent="Lines: "+e.info.render.lines,a[8].textContent="Points: "+e.info.render.points)}}}:function(){return{domElement:document.createElement("div"),update:function(e){}}});Y.stats&&(ze.domElement.style.position="absolute",ze.domElement.style.left="0px",ze.domElement.style.top="48px",document.body&&document.body.appendChild(ze.domElement));var Ge=function(e){function n(){var e;return Object(l.a)(this,n),(e=Object(c.a)(this,Object(d.a)(n).call(this,{id:"preloader"}))).preloadGpuCullScene=function(n){e.spinner.material.uniforms.opacity.value=n?1:0},e.animateInit=function(){h.b.killTweensOf(e.spinner.material.uniforms.opacity),e.spinner.material.uniforms.opacity.value=0},e.update=function(n){e.spinner.rotation.z-=2*n},e.camera.position.set(0,0,10),e.camera.lookAt(y),e}return Object(f.a)(n,e),Object(u.a)(n,[{key:"createSceneObjects",value:function(){var e=Object(A.a)(p.a.mark((function e(){var n=this;return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,t){try{n.spinner=new _.W(new _.vb(.9,1,32,1,0,.75*T),new _.xb({transparent:!0,uniforms:{opacity:{value:0}},vertexShader:"\n              varying vec2 vUv;\n              void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n              }\n            ",fragmentShader:"\n              uniform float opacity;\n              varying vec2 vUv;\n              void main() {\n                gl_FragColor = vec4(vUv, 1.0, vUv.y * opacity);\n              }\n          "})),n.spinner.name="spinner",n.scene.add(n.spinner),n.animateInit(),e()}catch(a){t(a)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"animateIn",value:function(){var e=Object(A.a)(p.a.mark((function e(){var n=this;return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,t){Y.skipTransitions?e():h.b.to(n.spinner.material.uniforms.opacity,1,{value:1,onComplete:function(){e()}})}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"animateOut",value:function(){var e=Object(A.a)(p.a.mark((function e(){var n=this;return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,t){Y.skipTransitions?e():h.b.to(n.spinner.material.uniforms.opacity,1,{value:0,onComplete:function(){e()}})}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()}]),n}(Te),He=function(){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Object(l.a)(this,e),this.ready=n.ready||!1}return Object(u.a)(e,[{key:"equals",value:function(e){return this.ready===e.ready}},{key:"clone",value:function(){return new e({ready:this.ready})}}]),e}(),Be=function(){function e(){var n=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Object(l.a)(this,e),this.onChange=function(){n.light.color.setHex(n.settings.color)},this.settings=Object.assign({color:13948116,intensity:.6,guiOpen:!1},t),this.light=new _.a(this.settings.color,this.settings.intensity)}return Object(u.a)(e,[{key:"gui",value:function(e){this.guiParent=e,this.gui=e.addFolder("ambient"),this.settings.guiOpen&&this.gui.open(),this.gui.add(this.light,"intensity",0,1,Y.guiPrecision),this.gui.addColor(this.settings,"color").onChange(this.onChange)}},{key:"dispose",value:function(){this.guiParent.removeFolder(this.gui.name)}}]),e}(),We=function(){function e(){var n=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Object(l.a)(this,e),this.onChange=function(){n.light.color.setHex(n.settings.color),n.helper.update()},this.settings=Object.assign({color:13948116,intensity:.6,guiOpen:!1},t),this.light=new _.q(this.settings.color,this.settings.intensity),this.light.position.set(1,1,1),this.helper=new _.r(this.light)}return Object(u.a)(e,[{key:"gui",value:function(e){this.guiParent=e,this.gui=e.addFolder("directional"),this.settings.guiOpen&&this.gui.open(),this.gui.addColor(this.settings,"color").onChange(this.onChange),this.gui.add(this.light,"intensity",0,1,Y.guiPrecision);this.gui.add(this.light.position,"x",-1,1).step(Y.guiPrecision).name("direction x"),this.gui.add(this.light.position,"y",-1,1).step(Y.guiPrecision).name("direction y"),this.gui.add(this.light.position,"z",-1,1).step(Y.guiPrecision).name("direction z")}},{key:"dispose",value:function(){this.guiParent.removeFolder(this.gui.name)}}]),e}(),Ve=[new re({id:"jam3-logo",src:"".concat(Y.baseUrl,"/assets/webgl/landing/jam3.glb"),type:le.threeGLTF})],qe="\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n",Je="\n  uniform vec3 color0;\n  uniform vec3 color1;\n  uniform float strength;\n  uniform float powStrength;\n  varying vec2 vUv;\n\n  void main() {\n    float y = distance(vec2(0.5), vec2(0.5, vUv.y)) * strength;\n    y = pow(y, powStrength);\n    vec3 color = mix(color0, color1, y);\n    gl_FragColor = vec4(color, 1.0);\n  }\n",Ke=function e(n){var t,a=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:50;Object(l.a)(this,e),this.onChange=function(){a.mesh.material.uniforms.color0.value.setHex(a.config.color0),a.mesh.material.uniforms.color1.value.setHex(a.config.color1)},this.guiParent=n,this.config={color0:0,color1:1776411};var o=new _.xb({uniforms:{color0:{value:new _.n(this.config.color0)},color1:{value:new _.n(this.config.color1)},strength:{value:2.5},powStrength:{value:1.3}},vertexShader:qe,fragmentShader:Je,side:_.d});this.gui=n.addFolder("background"),this.gui.open(),this.gui.add(o.uniforms.strength,"value",0,10).name("strength").onChange(this.onChange),this.gui.add(o.uniforms.powStrength,"value",0,10).name("powStrength").onChange(this.onChange),this.gui.addColor(this.config,"color0").onChange(this.onChange),this.gui.addColor(this.config,"color1").onChange(this.onChange);var r=(t={},Object(x.a)(t,"high",[32,16]),Object(x.a)(t,"normal",[18,8]),t),s=r[O()];this.mesh=new _.W(new _.Bb(i,s[0],s[1]),o),this.mesh.matrixAutoUpdate=!1,this.mesh.updateMatrix()},Ze=function(){function e(n){Object(l.a)(this,e),this.renderer=n,this.scene=new _.wb,this.camera=new _.jb(60,1,.01,5),this.camera.position.set(0,0,2),this.camera.lookAt(y),this.renderTarget=new _.Tb(128,128,{format:_.rb,stencilBuffer:!1}),this.mesh=new _.W(new _.Bb(1,32,32),new _.xb({vertexShader:"\n        varying vec3 vNormal;\n        void main() {\n          vNormal = normal;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      ",fragmentShader:"\n          varying vec3 vNormal;\n          void main() {\n            // Pack the normal range from (-1, 1), to (0, 1)\n            gl_FragColor = vec4(vNormal * 0.5 + 0.5, 1.0);\n          }\n        "})),this.scene.add(this.mesh)}return Object(u.a)(e,[{key:"render",value:function(e){this.renderer.setRenderTarget(this.renderTarget),this.camera.position.copy(e.position).setLength(2),this.camera.lookAt(y),this.renderer.render(this.scene,this.camera),this.renderer.setRenderTarget(null)}}]),e}(),$e=function(){function e(n,t,a,i){Object(l.a)(this,e),this.config={totalParticles:t,size:{min:.1,max:5}},this.scene=new _.wb;var o=G(),r=o.width,s=o.height;this.renderTarget=B(r,s),this.attributes={position:new _.h(new Float32Array(3*this.config.totalParticles),3),size:new _.h(new Float32Array(this.config.totalParticles),1)};for(var u=0;u<this.config.totalParticles;u++){var c=this.spherePoint(0,0,0,Math.random(),Math.random(),_.S.randFloat(10,50)),d=c.x,f=c.y,h=c.z;this.attributes.position.setXYZ(u,d,f,h);var m=_.S.randFloat(this.config.size.min,this.config.size.max)*i;this.attributes.size.setX(u,m)}var p=new _.i;p.addAttribute("position",this.attributes.position),p.addAttribute("size",this.attributes.size);var A=new _.xb({uniforms:{particleSize:{value:100},lightDirection:{value:new _.Pb(1,1,1)},normalMap:{value:a.renderTarget.texture}},vertexShader:"\n  attribute float size; // Per particle size attribute\n  uniform float particleSize; // Uniform particle size (affects all)\n  varying vec3 vPosition; // Vertex position for fragment shader\n\n  void main() {\n    // Model view position\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n    // Scale point size based on distance\n    gl_PointSize = size * (particleSize / length(mvPosition.xyz));\n    // Screen space projection\n    gl_Position = projectionMatrix * mvPosition;\n    // Set position varying\n    vPosition = position;\n  }\n",fragmentShader:"\n  uniform vec3 lightDirection;\n  uniform sampler2D normalMap;\n  varying vec3 vPosition;\n\n  // Signed distance function for 2D circle\n  float circle(vec2 uv, vec2 pos, float rad) {\n    float d = length(pos - uv) - rad;\n    return step(d, 0.0);\n  }\n\n  void main() {\n    float c = circle(vec2(0.5), gl_PointCoord.xy, 0.5);\n    // Discard any pixels outside of circle\n    if (c == 0.0) discard;\n\n    vec4 outgoingColor = vec4(1.0);\n\n    // Sample normal from texture, y coords are inverted from render target\n    vec3 normal = texture2D(normalMap, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y)).rgb * 2.0 - 1.0;\n    // Second normal based on spherical particle position\n    vec3 normal2 = normalize(vPosition);\n\n    // Half lambert lighting model\n    float intensity = max(0.2, dot(normal, lightDirection) * 0.5 + 0.5);\n    float intensty2 = max(0.5, dot(normal2, lightDirection) * 0.5 + 0.5);\n\n    // Base color on normal\n    normal2.b = 1.0;\n    vec3 color = vec3(normal2 * 0.5 + 0.5);\n\n    // Apply lambert intensity\n    color *= intensity;\n    color *= intensty2;\n\n    // Set outgoing color\n    outgoingColor.rgb = color;\n\n    gl_FragColor = outgoingColor;\n  }\n"});n.add(A.uniforms.lightDirection.value,"x",-1,1).name("light x"),n.add(A.uniforms.lightDirection.value,"y",-1,1).name("light y"),n.add(A.uniforms.lightDirection.value,"z",-1,1).name("light z"),this.mesh=new _.mb(p,A),this.scene.add(this.mesh)}return Object(u.a)(e,[{key:"render",value:function(e,n){this.mesh.rotation.y+=.1*e,De.setRenderTarget(this.renderTarget),De.render(this.scene,n),De.setRenderTarget(null)}},{key:"spherePoint",value:function(e,n,t,a,i,o){var r=2*Math.PI*a,s=Math.acos(2*i-1);return{x:e+o*Math.sin(s)*Math.cos(r),y:n+o*Math.sin(s)*Math.sin(r),z:t+o*Math.cos(s)}}}]),e}(),en=function(){function e(n,t){var a=this;Object(l.a)(this,e),this.gui=n.addFolder("Jam3"),this.gui.open(),this.group=new _.B;var i=G(),o=i.width,r=i.height;this.material=new _.xb({uniforms:{particleMap:{value:t.texture},resolution:{value:new _.Ob(o,r)},cameraPosition:{value:new _.Pb(1,1,1)},fresnelPow:{value:25}},vertexShader:"\n  varying vec3 vWorldPosition;\n  varying vec3 vNormal;\n  void main() {\n    vNormal = normal;\n    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n",fragmentShader:"\n  uniform float fresnelPow;\n  uniform vec2 resolution;\n  varying vec3 vNormal;\n  varying vec3 vWorldPosition;\n  uniform sampler2D particleMap;\n\n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec3 texel = texture2D(particleMap, uv).rgb;\n    vec3 normal = normalize( vNormal );\n    vec3 eye = cameraPosition - vWorldPosition.xyz;\n    float cosTheta = abs(dot(normalize(eye), normal));\n    float fresnel = pow(cosTheta, fresnelPow);\n    vec3 shine = vec3(fresnel);\n    gl_FragColor = vec4(mix(texel, shine, 0.25), 1.0);\n  }\n"});var s=Pe.get("landing","jam3-logo");if("object"===typeof s&&null!==s){var u,c=null===(u=s.scene.children[0])||void 0===u?void 0:u.children[0];c.scale.set(300,300,300),c.children.forEach((function(e){e.material=a.material})),this.group.add(c)}this.gui.add(this.material.uniforms.fresnelPow,"value",0,50).name("fresnelPow")}return Object(u.a)(e,[{key:"resize",value:function(e,n){this.material.uniforms.resolution.value.set(e,n)}},{key:"update",value:function(e){this.material.uniforms.cameraPosition.value.copy(e.position)}}]),e}(),nn=function(e){function n(){var e;Object(l.a)(this,n);var t=[new Be,new We];return Y.devCamera=!1,(e=Object(c.a)(this,Object(d.a)(n).call(this,{id:"landing",assets:Ve,gui:!0,guiOpen:!0,lights:t,controls:!0}))).update=function(n){e.controls.main.update(),e.particlesNormal.render(e.camera),e.particles.render(n,e.camera),e.jam3.update(e.camera)},e.cameras.main.position.set(0,0,60),e.cameras.main.lookAt(y),e.controls.main.enableDamping=!0,e}return Object(f.a)(n,e),Object(u.a)(n,[{key:"createSceneObjects",value:function(){var e=Object(A.a)(p.a.mark((function e(){var n=this;return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,t){try{n.background=new Ke(n.gui,100),n.scene.add(n.background.mesh),n.particlesNormal=new Ze(De),n.particles=new $e(n.gui,5e3,n.particlesNormal,De.getPixelRatio()),n.jam3=new en(n.gui,n.particles.renderTarget),n.scene.add(n.jam3.group),e()}catch(a){t(a)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()}]),n}(Te),tn=[],an=t(22),on=new _.Bb(.1,16,16),rn=new _.X,sn=new _.I({color:16777215}),ln=new _.I({color:16776960}),un=function(e){function n(e,t,a,i,o,r){var s,u,f;return Object(l.a)(this,n),(f=Object(c.a)(this,Object(d.a)(n).call(this))).toggleVisibility=function(e){f.group.visible=e,f.gui[e?"open":"close"](),f.toggleControls(e)},f.createSmoothSpline=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10,t=new _.k(e),a=t.getPoints(n);return{curve:t=new _.k(a),points:a}},f.getCameraDataByTime=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=f.curves.origin.curve.getPointAt(e),t=f.curves.lookat.curve.getPointAt(e);return{origin:n,lookat:t}},f.updateSplines=function(){f.curves.origin=f.createSmoothSpline(f.origin,f.steps),f.curves.lookat=f.createSmoothSpline(f.lookat,f.steps)},f.addControl=function(e,n,t){var a=new _.W(on,rn);a.position.copy(t),f.points.add(a);var i=new an.a(f.camera,De.domElement);i.enabled=f.controls.visible,f.controls.add(i),i.addEventListener("dragging-changed",f.onTransformChanged),i.attach(a),f.curvePoints[e][n]=a.position},f.createLine=function(e,n){var t=new _.z;t.vertices=e;var a=new _.H(t,n);f.lines.add(a),f.lineMeshes.push(a)},f.onTransformChanged=function(e){f.control.enabled=!e.value,f.rebuild()},f.rebuild=function(){for(var e=0;e<f.origin.length;e++)f.origin[e].copy(f.curvePoints.origin[e]);for(var n=0;n<f.lookat.length;n++)f.lookat[n].copy(f.curvePoints.lookat[n]);f.updateSplines(),f.removeLines(),f.createLine(f.curves.origin.points,sn),f.createLine(f.curves.lookat.points,ln)},f.export=function(){var e=JSON.stringify({steps:f.steps,origin:f.origin,lookat:f.lookat},void 0,2);window.prompt("Copy to clipboard: Ctrl+C, Enter",e)},f.dispose=function(){for(var e=0;e<f.controls.children.length;e++)f.controls.children[e].removeEventListener("dragging-changed",f.onTransformDragChanged)},f.group=new _.B,f.steps=t.steps,f.camera=i,f.control=o,f.origin=[],f.lookat=[],f.gui=a.addFolder("".concat(e," camera dolly")),t.origin.forEach((function(e){f.origin.push(new _.Pb(e.x,e.y,e.z))})),t.lookat.forEach((function(e){f.lookat.push(new _.Pb(e.x,e.y,e.z))})),f.curves=(s={},Object(x.a)(s,"origin",f.createSmoothSpline(f.origin,f.steps)),Object(x.a)(s,"lookat",f.createSmoothSpline(f.lookat,f.steps)),s),f.controls=new _.B,f.controls.visible=r.controlsVisible,f.group.add(f.controls),f.points=new _.B,f.points.visible=r.pointsVisible,f.group.add(f.points),f.curvePoints=(u={},Object(x.a)(u,"origin",[]),Object(x.a)(u,"lookat",[]),u),f.origin.forEach((function(e,n){f.addControl("origin",n,e)})),f.lookat.forEach((function(e,n){f.addControl("lookat",n,e)})),f.lines=new _.B,f.lines.visible=r.linesVisible,f.lineMeshes=[],f.group.add(f.lines),f.createLine(f.curves.origin.points,sn),f.createLine(f.curves.lookat.points,ln),f.gui.add(Object(F.a)(f),"steps",5,100,1).onChange(f.rebuild),f.gui.add(f.controls,"visible").name("controls").onChange((function(e){f.toggleControls(e)})),f.gui.add(f.points,"visible").name("points"),f.gui.add(f.lines,"visible").name("lines"),f.gui.add(Object(F.a)(f),"export"),f.gui.open(),f}return Object(f.a)(n,e),Object(u.a)(n,[{key:"toggleControls",value:function(e){for(var n=0;n<this.controls.children.length;n++)this.controls.children[n].enabled=this.controls.visible&&this.group.visible}},{key:"removeLines",value:function(){for(var e=0;e<this.lineMeshes.length;e++)this.lines.remove(this.lineMeshes[e])}}]),n}(v.a),cn=function(){function e(n){var t=this;Object(l.a)(this,e),this.onTrackChange=function(e){t.setTransition(e,t.camera)},this.update=function(){if(void 0!==t.dollies[t.dollyId]){var e=t.dollies[t.dollyId].getCameraDataByTime(t.time),n=e.origin,a=e.lookat;t.camera.position.set(n.x,n.y,n.z),t.lookat.set(a.x,a.y,a.z),t.camera.lookAt(t.lookat)}},this.time=0,this.group=new _.B,this.dollies={},this.dollyId="",this.dollyIds=[],this.lookat=new _.Pb,this.camera=null,this.options=n,n.gui?(this.gui=n.gui.addFolder("camera dolly manager"),n.guiOpen&&this.gui.open(),this.gui.add(this,"time",0,1).listen().onChange(this.update)):this.gui=new $,this.tracksGui=this.gui.addFolder("tracks"),this.tracksGui.open()}return Object(u.a)(e,[{key:"addTransition",value:function(e,n,t,a,i,o){this.dollies[e]=new un(e,n,this.gui,a,i,o),this.dollies[e].on("rebuild",this.update),this.group.add(this.dollies[e].group),this.setTransition(e,t)}},{key:"setTransition",value:function(e,n){var t=this;this.dollyId=e,this.dollyIds.includes(e)||this.dollyIds.push(e),this.gui.removeFolder(this.tracksGui.name),this.tracksGui=this.gui.addFolder("tracks"),this.tracksGui.open(),this.tracksGui.add(this,"dollyId",this.dollyIds).onChange(this.onTrackChange),this.camera=n,Object.keys(this.dollies).forEach((function(n){var a=n===e;t.dollies[n].toggleVisibility(a)})),this.update()}},{key:"transition",value:function(){var e=Object(A.a)(p.a.mark((function e(){var n,t,a=this,i=arguments;return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return n=i.length>0&&void 0!==i[0]?i[0]:1,t=i.length>1&&void 0!==i[1]?i[1]:h.a.easeOut,e.next=4,new Promise((function(e,i){h.c.killTweensOf(a),a.time=0,a.update(),h.c.to(a,n,{time:1,ease:t,onUpdate:function(){a.update()},onComplete:function(){e()}})}));case 4:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"stop",value:function(){h.c.killTweensOf(this)}},{key:"dispose",value:function(){var e=this;this.stop(),Object.keys(this.dollies).forEach((function(n){e.dollies[n].dispose()})),this.options.gui&&this.options.gui.removeFolder(this.gui.name)}}]),e}(),dn=function(e){function n(){var e;Object(l.a)(this,n),Y.devCamera=!0;var t=[new Be,new We];return(e=Object(c.a)(this,Object(d.a)(n).call(this,{id:"camera-transitions",assets:tn,gui:!0,guiOpen:!0,lights:t,controls:!0}))).play=function(){e.animateCamera()},e.stop=function(){e.cameraDollyManager.stop()},V(e.cameras.dev,50),e}return Object(f.a)(n,e),Object(u.a)(n,[{key:"createSceneObjects",value:function(){var e=Object(A.a)(p.a.mark((function e(){var n=this;return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,a){try{n.controls.main.enabled=!1,n.gui.add(n,"play"),n.gui.add(n,"stop");var i=new _.j(n.cameras.main);n.scene.add(i);var o={"track 0":t(48),"track 1":t(49)};n.trackIds=Object.keys(o),n.trackIndex=1,n.cameraDollyManager=new cn({gui:n.gui,guiOpen:!0}),n.scene.add(n.cameraDollyManager.group),Object.keys(o).forEach((function(e){n.cameraDollyManager.addTransition(e,o[e],n.cameras.main,n.cameras.dev,n.controls.dev,{linesVisible:!0,controlsVisible:!1,pointsVisible:!0})})),n.play(),e()}catch(r){a(r)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"animateCamera",value:function(){var e=this;this.cameraDollyManager.setTransition(this.trackIds[this.trackIndex],this.cameras.main),this.cameraDollyManager.transition(5,h.a.easeOut).then((function(){e.trackIndex++,e.trackIndex%=e.trackIds.length,e.animateCamera()}))}}]),n}(Te),fn=t(23),hn=function e(n,t,a){var i=this,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;Object(l.a)(this,e),this.save=function(){i.canvas.toBlob((function(e){Object(fn.saveAs)(e,"screenshot.jpg")}),"image/jpeg",.75)},this.capture=function(e,n){i.ctx.clearRect(0,0,i.canvas.width,i.canvas.height);var t=n.aspect;n.aspect=i.width/i.height,n.updateProjectionMatrix();var a=je.finalPass.mesh.material.uniforms.resolution.value.x,o=je.finalPass.mesh.material.uniforms.resolution.value.y,r=z.x,s=z.y;De.setViewport(0,0,r,s),De.setScissor(0,0,r,s),je.finalPass.resize(i.width,i.height),De.setRenderTarget(i.renderTargetA),De.render(e,n),De.setRenderTarget(null),je.finalPass.screenshotRender(e,n,i.renderTargetA,i.renderTargetB,0),De.readRenderTargetPixels(i.renderTargetB,0,0,i.renderTargetB.width,i.renderTargetB.height,i.pixelBuffer),i.imageData.data.set(i.pixelBuffer),i.ctxFlipped.putImageData(i.imageData,0,0),i.ctx.save(),i.ctx.scale(1,-1),i.ctx.drawImage(i.canvasFlipped,0,-i.canvas.height,i.canvas.width,i.canvas.height),i.ctx.restore(),n.aspect=t,n.updateProjectionMatrix(),je.finalPass.resize(a,o),i.save()},this.gui=n.addFolder("screenshot"),this.gui.open(),this.width=t*o,this.height=a*o,this.renderTargetA=new _.Tb(this.width,this.height,{minFilter:_.L,magFilter:_.L,format:_.rb,stencilBuffer:!1}),this.renderTargetB=new _.Tb(this.width,this.height,{minFilter:_.L,magFilter:_.L,format:_.rb,stencilBuffer:!1});var r=te(this.width,this.height),s=r.canvas,u=r.ctx,c=te(this.width,this.height),d=c.canvas,f=c.ctx;this.canvas=s,this.canvasFlipped=d,this.ctx=u,this.ctxFlipped=f,this.pixelBuffer=new Uint8Array(this.renderTargetA.width*this.renderTargetA.height*4),this.imageData=this.ctxFlipped.createImageData(this.canvas.width,this.canvas.height)},mn={preTransform:"before:#include <begin_vertex>\n",postTransform:"after:#include <project_vertex>\n",preNormal:"before:#include <beginnormal_vertex>\n"},pn={preFragColor:"before:gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n",postFragColor:"after:gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n",postNormal:"after:#include <normal_fragment>\n",postFragFog:"after:#include <fog_fragment>\n"};function An(e,n,t){return Object.keys(n).forEach((function(a){if(t[a]){var i=n[a].split(":"),o=i[1];switch(i[0]){case"after":e=e.replace(o,"".concat(o,"\n            ").concat(t[a]));break;default:e=e.replace(o,"".concat(t[a],"\n            ").concat(o))}}})),e}var xn={uniforms:{time:{value:0}},vertexShader:{uniforms:"\n      uniform float time;\n      varying vec3 vNormal;\n    ",functions:"\n      ".concat("\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat simplexNoise3D(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n","\n    "),preTransform:"",postTransform:"\n      float speed = time * 0.5;\n      float noise = simplexNoise3D(position.xyz * 0.75 + speed) * 0.15;\n      transformed = normal * noise;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position + transformed, 1.0);\n      vNormal = normal;\n    "},fragmentShader:{uniforms:"\n      varying vec3 vNormal;\n    ",functions:"",preFragColor:"\n      vec3 normal = normalize(vNormal);\n      normal.b = 1.0;\n      outgoingLight *= (normal * 0.5 + 0.5);\n    ",postFragColor:"\n      gl_FragColor.a = opacity;\n    "}},Fn=function(e){function n(e,t){var a;return Object(l.a)(this,n),(a=Object(c.a)(this,Object(d.a)(n).call(this))).bindEvents=function(e){var n=e?"addEventListener":"removeEventListener",t=K.a.device.isDesktop;a.options.touchStart&&a.element[n](t?"mousedown":"touchstart",a.onTouchStart),a.options.touchMove&&a.element[n](t?"mousemove":"touchmove",a.onTouchMove),a.options.touchEnd&&a.element[n](t?"mouseup":"touchend",a.onTouchEnd),t&&(a.options.hover&&a.element[n]("mouseover",a.onMouseOver),a.options.hover&&a.element[n]("mouseout",a.onMouseOut))},a.setPointers=function(e){if(a.pointers=[],e.touches){a.touchesLength=e.touches.length;for(var n=0;n<a.touchesLength;n++){var t=e.touches[n];a.pointers.push({x:t.pageX,y:t.pageY,normalX:t.pageX/window.innerWidth,normalY:t.pageY/window.innerHeight})}}else a.pointers.push({x:e.pageX,y:e.pageY,normalX:e.pageX/window.innerWidth,normalY:e.pageY/window.innerHeight})},a.onTouchStart=function(e){a.isDown=!0,a.setPointers(e),a.emit("start",a.pointers)},a.onTouchMove=function(e){a.onMouseMove(e),a.isDown&&(a.setPointers(e),a.emit("move",a.pointers))},a.onTouchEnd=function(){a.isDown=!1,a.emit("end",a.pointers)},a.onMouseMove=function(e){a.setPointers(e),a.emit("mousemove",a.pointers)},a.onMouseOver=function(e){a.emit("hover",!0)},a.onMouseOut=function(e){a.emit("hover",!1)},a.dispose=function(){a.bindEvents(!1)},a.element=e,a.pointers=[],a.options=Object.assign({hover:!1,touchStart:!0,touchMove:!0,touchEnd:!0},t),a.touchesLength=0,a.isDown=!1,a.bindEvents(!0),a}return Object(f.a)(n,e),n}(v.a),gn=function(e){function n(e,t){var a,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return Object(l.a)(this,n),(a=Object(c.a)(this,Object(d.a)(n).call(this))).bindEvents=function(e){var n=e?"on":"off";a.options.touchStart&&a.touchControls[n]("start",a.onTouchStart),a.options.touchMove&&a.touchControls[n]("move",a.onTouchMove),a.options.touchMove&&a.touchControls[n]("mousemove",a.onTouchMove),(a.options.touchEnd||a.options.touchMove)&&a.touchControls[n]("end",a.onTouchEnd)},a.onTouchStart=function(e){a.setCoords(e[0].normalX,e[0].normalY),a.intersected=a.raycast(),a.intersected&&a.emit("start",a.intersects[0])},a.onTouchMove=function(e){a.setCoords(e[0].normalX,e[0].normalY),a.intersected=a.raycast(),a.hovering=a.intersected,a.intersected?(a.fired.hoverOver&&!a.options.mouseMove||a.emit("hover",!0,a.intersects[0]),a.fired.hoverOut=!1,a.fired.hoverOver=!0):a.fired.hoverOut||(a.fired.hoverOut=!0,a.fired.hoverOver=!1,a.emit("hover",!1))},a.onTouchEnd=function(e){a.hovering&&(a.hovering=!1,a.emit("hover",!1)),a.intersected&&(a.intersected=!1,a.emit("end"))},a.setCoords=function(e,n){a.coords.x=2*e-1,a.coords.y=2*-n+1},a.raycast=function(){return a.raycaster.setFromCamera(a.coords,a.camera),a.intersects=a.raycaster.intersectObject(a.object),a.intersects.length>0},a.dispose=function(){a.touchControls.dispose(),a.bindEvents(!1)},a.object=e,a.camera=t,a.options=Object.assign({mouseMove:!1,touchStart:!0,touchMove:!0,touchEnd:!0},i),a.touchControls=new Fn(De.domElement,{hover:!0}),a.raycaster=new _.tb,a.coords=new _.Ob,a.intersects=null,a.fired={hoverOut:!0,hoverOver:!1},a.bindEvents(!0),a}return Object(f.a)(n,e),n}(v.a),vn=function(){function e(n){var t=this;Object(l.a)(this,e),this.onStart=function(e){t.scaleMesh(!0)},this.onHover=function(e,n){},this.onEnd=function(){t.scaleMesh(!1)},this.preloadGpuCullScene=function(e){t.mesh.material.opacity=e?1:0},this.animateInit=function(){h.b.killTweensOf(t.mesh.material.opacity),t.mesh.material.opacity=0},this.scaleMesh=function(e){h.b.killTweensOf(t.mesh.scale),h.b.to(t.mesh.scale,.5,{x:e?1.6:1,y:e?1.6:1,z:e?1.6:1})},this.camera=n;var a="high"===O()?64:32,i=new _.Bb(1,a,a),o=new _.Y({transparent:!0,opacity:0});this.shader=void 0;var r=!1;o.onBeforeCompile=function(e){r||(r=!0,t.shader=function(e,n){return e.uniforms=_.Mb.merge([e.uniforms,n.uniforms]),e.vertexShader="\n    ".concat(n.vertexShader.uniforms,"\n    ").concat(n.vertexShader.functions,"\n    ").concat(e.vertexShader,"\n  "),e.fragmentShader="\n    ".concat(n.fragmentShader.uniforms,"\n    ").concat(n.fragmentShader.functions,"\n    ").concat(e.fragmentShader,"\n  "),e.vertexShader=An(e.vertexShader,mn,n.vertexShader),e.fragmentShader=An(e.fragmentShader,pn,n.fragmentShader),e}(e,xn))},this.mesh=new _.W(i,o),this.interactiveObject=new gn(this.mesh,this.camera,{touchStart:!0,touchMove:!0,touchEnd:!0,mouseMove:!1}),this.interactiveObject.on("start",this.onStart),this.interactiveObject.on("hover",this.onHover),this.interactiveObject.on("end",this.onEnd)}return Object(u.a)(e,[{key:"animateIn",value:function(){var e=Object(A.a)(p.a.mark((function e(){var n=this;return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,t){h.b.to(n.mesh.material,1,{opacity:1,onComplete:function(){e()}})}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"animateOut",value:function(){var e=Object(A.a)(p.a.mark((function e(){var n=this;return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,t){h.b.to(n.mesh.material,1,{opacity:0,onComplete:function(){e()}})}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"update",value:function(e){this.shader&&(this.shader.uniforms.time.value+=e)}}]),e}(),_n=[],Pn=function(e){function n(){var e;Object(l.a)(this,n),Y.devCamera=!1;var t=[new Be,new We];return(e=Object(c.a)(this,Object(d.a)(n).call(this,{id:"interactive-sphere",assets:_n,gui:!0,guiOpen:!0,lights:t,controls:!0}))).preloadGpuCullScene=function(n){e.sphere.preloadGpuCullScene(n)},e.animateInit=function(){return e.sphere.animateInit()},e.animateIn=function(){return e.sphere.animateIn()},e.animateOut=function(){return e.sphere.animateOut()},e.update=function(n){e.sphere.update(n)},e.camera.position.set(0,0,5),e.camera.lookAt(y),e}return Object(f.a)(n,e),Object(u.a)(n,[{key:"createSceneObjects",value:function(){var e=Object(A.a)(p.a.mark((function e(){var n=this;return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,t){try{n.background=new Ke(n.gui),n.scene.add(n.background.mesh),n.sphere=new vn(n.camera),n.scene.add(n.sphere.mesh),n.animateInit(),e()}catch(a){t(a)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()}]),n}(Te),Tn=function(e){function n(e){var t,a;Object(l.a)(this,n),(a=Object(c.a)(this,Object(d.a)(n).call(this))).captureScreenshot=function(){a.screenshot.capture(a.currentScene.scene,a.currentScene.camera)},a.setState=function(e){e.equals(a.state)||(a.prevState=a.state.clone(),a.state=e,a.onStateChanged(a.state))},a.onStateChanged=function(e){a.state.ready&&a.state.ready!==a.prevState.ready&&a.setScene(a.sceneId)},a.resize=function(e,n){H(De,e,n),a.currentScene.resize(e,n),je.resize(),a.viewport.debug.set(0,0,z.x*Y.viewportPreviewScale,z.y*Y.viewportPreviewScale),a.viewport.main.set(0,0,z.x,z.y)},a.renderScene=function(e,n,t,i){De.setViewport(n.x,n.y,n.z,n.w),De.setScissor(n.x,n.y,n.z,n.w),i?je.render(t):(a.currentScene.update(a.delta),De.setClearColor(a.currentScene.clearColor),De.render(a.currentScene.scene,e))},a.render=function(e){a.isRendering!==e&&(a.isRendering=e,e?a.update():cancelAnimationFrame(a.rafId))},a.update=function(){a.rafId=requestAnimationFrame(a.update),a.delta=a.clock.getDelta(),Y.devCamera?(a.renderScene(a.currentScene.cameras.dev,a.viewport.main,a.delta,!1),a.renderScene(a.currentScene.cameras.main,a.viewport.debug,a.delta,!0)):a.renderScene(a.currentScene.cameras.main,a.viewport.main,a.delta,!0),Y.stats&&ze.update(De)},e.appendChild(De.domElement),a.clock=new _.m(!0),a.rafId=0,a.delta=0,a.isRendering=!1,a.state=new He({ready:!1}),a.scenes=(t={},Object(x.a)(t,"preloader",Ge),Object(x.a)(t,"landing",nn),Object(x.a)(t,"interactive-sphere",Pn),Object(x.a)(t,"camera-transitions",dn),t);var i=["landing","interactive-sphere","camera-transitions"];a.sceneId="landing",i.includes(L("sceneId"))&&(a.sceneId=L("sceneId")),a.viewport={debug:new _.Qb(0,0,z.x*Y.viewportPreviewScale,z.y*Y.viewportPreviewScale),main:new _.Qb(0,0,z.x,z.y)},a.screenshot=new hn(ne,1280,720,2),a.screenshot.gui.add(Object(F.a)(a),"captureScreenshot").name("capture");var o=ne.addFolder("settings");return o.open(),o.add(Y,"devCamera").onChange((function(e){w("devCamera",e),je.resize(),a.currentScene.toogleCameras(e)})),o.add(Y,"helpers").onChange((function(e){w("helpers",e),a.currentScene.toggleHelpers(e)})),o.add(Object(F.a)(a),"sceneId",i).onChange((function(e){a.setScene(e),w("sceneId",e)})).listen(),a}return Object(f.a)(n,e),Object(u.a)(n,[{key:"setup",value:function(){var e=Object(A.a)(p.a.mark((function e(){var n=this;return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,t){try{n.setScene("preloader").then(e).catch(t)}catch(a){t(a)}}));case 2:case"end":return e.stop()}}),e)})));return function(){return e.apply(this,arguments)}}()},{key:"setScene",value:function(){var e=Object(A.a)(p.a.mark((function e(n){var t=this;return p.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,new Promise((function(e,a){if(!t.currentScene||n!==t.currentScene.id){var i=new t.scenes[n];i.setup().then((function(){var n=t.currentScene,o=function(){t.currentScene=i,t.currentScene.animateIn().then(e,a),je.setScenes(je.sceneB,i),je.transitionPass.transition().then((function(){n&&n.dispose()}))};n?n.animateOut().then(o).catch(a):o()})).catch(a)}}));case 2:case"end":return e.stop()}}),e)})));return function(n){return e.apply(this,arguments)}}()}]),n}(v.a),yn=function(e){function n(){var e,t;Object(l.a)(this,n);for(var a=arguments.length,i=new Array(a),o=0;o<a;o++)i[o]=arguments[o];return(t=Object(c.a)(this,(e=Object(d.a)(n)).call.apply(e,[this].concat(i)))).state={ready:!1,windowSize:{width:window.innerWidth,height:window.innerHeight}},t.onReady=function(){t.setState({ready:!0})},t.onResize=function(){t.setState({windowSize:{width:window.innerWidth,height:window.innerHeight}})},t}return Object(f.a)(n,e),Object(u.a)(n,[{key:"componentDidMount",value:function(){var e=this;null!==this.container&&(this.webglApp=new Tn(this.container),this.webglApp.setup().then((function(){e.webglApp.setState(new He(e.state)),e.webglApp.render(!0),h.b.delayedCall(1,e.onReady)})).catch((function(e){console.log(e)})),window.addEventListener("resize",this.onResize))}},{key:"componentDidUpdate",value:function(e,n){null!==this.container&&(this.webglApp.setState(new He(this.state)),this.state.windowSize.width===n.windowSize.width&&this.state.windowSize.height===n.windowSize.height||this.webglApp.resize(this.state.windowSize.width,this.state.windowSize.height))}},{key:"componentWillUnmount",value:function(){null!==this.container&&(this.webglApp.render(!1),window.removeEventListener("resize",this.onResize))}},{key:"render",value:function(){var e=this;return o.a.createElement("div",{className:"App",ref:function(n){e.container=n}})}}]),n}(o.a.PureComponent),bn=document.getElementById("root");bn&&s.a.render(o.a.createElement(yn,null),bn)}},[[27,1,2]]]);
//# sourceMappingURL=main.a9562198.chunk.js.map